package com.codetoon.game.menuPanel;

import javax.swing.JPanel;
import java.awt.TextArea;
import javax.swing.JLabel;
import java.awt.Font;
import java.awt.Color;

/**
 * Create class information for declaring class tutorial panel
 * @author: Group 2D
 */
public class DecClasses extends JPanel {

	/***************constructor********************/
	public DecClasses() {
	    setLayout(null);// set layout
		
		
		// set information about declaring class and set font, type for text area
		TextArea textArea = new TextArea();
		textArea.setBackground(Color.WHITE);
		textArea.setEditable(false);
		textArea.setFont(new Font("Times New Roman", Font.PLAIN, 12));
		textArea.setText("You've seen classes defined in the following way:\r\n\r\nclass MyClass {\r\n    // field, constructor, and \r\n    // method declarations\r\n}\r\n\r\nThis is a class declaration. The class body (the area between the braces) contains all the code that provides for the life cycle of the objects created from the class: constructors for initializing new objects, declarations for the fields that provide the state of the class and its objects, and methods to implement the behavior of the class and its objects.\r\nThe preceding class declaration is a minimal one. It contains only those components of a class declaration that are required. You can provide more information about the class, such as the name of its superclass, whether it implements any interfaces, and so on, at the start of the class declaration. For example,\r\n\r\nclass MyClass extends MySuperClass implements YourInterface {\r\n    // field, constructor, and\r\n    // method declarations\r\n}\r\nmeans that MyClass is a subclass of MySuperClass and that it implements the YourInterface interface.\r\n\r\nYou can also add modifiers like public or private at the very beginning\u2014so you can see that the opening line of a class declaration can become quite complicated. The modifiers public and private, which determine what other classes can access MyClass, are discussed later in this lesson. The lesson on interfaces and inheritance will explain how and why you would use the extends and implements keywords in a class declaration. For the moment you do not need to worry about these extra complications.\r\n\r\nIn general, class declarations can include these components, in order:\r\n1. Modifiers such as public, private, and a number of others that you will encounter later. \r\n2. The class name, with the initial letter capitalized by convention. \r\n3. The name of the class's parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent. \r\n4. A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface. \r\n5. The class body, surrounded by braces, {}. \r\n\r\nDeclaring Member Variables\r\n\r\nThere are several kinds of variables:\r\nMember variables in a class\u2014these are called fields. \r\nVariables in a method or block of code\u2014these are called local variables. \r\nVariables in method declarations\u2014these are called parameters. \r\n\r\nThe Bicycle class uses the following lines of code to define its fields:\r\npublic int cadence;\r\npublic int gear;\r\npublic int speed;\r\n\r\nField declarations are composed of three components, in order:\r\n1. Zero or more modifiers, such as public or private. \r\n2. The field's type. \r\n3. The field's name. \r\n\r\nThe fields of Bicycle are named cadence, gear, and speed and are all of data type integer (int). The public keyword identifies these fields as public members, accessible by any object that can access the class.\r\n\r\nAccess Modifiers\r\n\r\nThe first (left-most) modifier used lets you control what other classes have access to a member field. For the moment, consider only public and private. Other access modifiers will be discussed later.\r\npublic modifier\u2014the field is accessible from all classes. \r\nprivate modifier\u2014the field is accessible only within its own class. \r\n\r\nIn the spirit of encapsulation, it is common to make fields private. This means that they can only be directly accessed from the Bicycle class. We still need access to these values, however. This can be done indirectly by adding public methods that obtain the field values for us:\r\n\r\npublic class Bicycle {\r\n        \r\n    private int cadence;\r\n    private int gear;\r\n    private int speed;\r\n        \r\n    public Bicycle(int startCadence, int startSpeed, int startGear) {\r\n        gear = startGear;\r\n        cadence = startCadence;\r\n        speed = startSpeed;\r\n    }\r\n        \r\n    public int getCadence() {\r\n        return cadence;\r\n    }\r\n        \r\n    public void setCadence(int newValue) {\r\n        cadence = newValue;\r\n    }\r\n        \r\n    public int getGear() {\r\n        return gear;\r\n    }\r\n        \r\n    public void setGear(int newValue) {\r\n        gear = newValue;\r\n    }\r\n        \r\n    public int getSpeed() {\r\n        return speed;\r\n    }\r\n        \r\n    public void applyBrake(int decrement) {\r\n        speed -= decrement;\r\n    }\r\n        \r\n    public void speedUp(int increment) {\r\n        speed += increment;\r\n    }\r\n}\r\n\r\nTypes\r\n\r\nAll variables must have a type. You can use primitive types such as int, float, boolean, etc. Or you can use reference types, such as strings, arrays, or objects.\r\n\r\nVariable Names\r\n\r\nAll variables, whether they are fields, local variables, or parameters, follow the same naming rules and conventions that were covered in the Language Basics lesson, Variables\u2014Naming.\r\nIn this lesson, be aware that the same naming rules and conventions are used for method and class names, except that\r\nthe first letter of a class name should be capitalized, and \r\nthe first (or only) word in a method name should be a verb. \r\n\r\nDefining Methods\r\n\r\nHere is an example of a typical method declaration:\r\npublic double calculateAnswer(double wingSpan, int numberOfEngines,\r\n                              double length, double grossTons) {\r\n    //do the calculation here\r\n}\r\n\r\nThe only required elements of a method declaration are the method's return type, name, a pair of parentheses, (), and a body between braces, {}.\r\n\r\nMore generally, method declarations have six components, in order:\r\n1. Modifiers\u2014such as public, private, and others you will learn about later. \r\n2. The return type\u2014the data type of the value returned by the method, or void if the method does not return a value. \r\n3. The method name\u2014the rules for field names apply to method names as well, but the convention is a little different. \r\n4. The parameter list in parenthesis\u2014a comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, (). If there are no parameters, you must use empty parentheses. \r\n5. An exception list\u2014to be discussed later. \r\n6. The method body, enclosed between braces\u2014the method's code, including the declaration of local variables, goes here. \r\n\r\nModifiers, return types, and parameters will be discussed later in this lesson. Exceptions are discussed in a later lesson. \r\n\r\nDefinition:\u00A0Two of the components of a method declaration comprise the method signature\u2014the method's name and the parameter types. \r\n\r\nThe signature of the method declared above is:\r\ncalculateAnswer(double, int, double, double)\r\n\r\nOverloading Methods\r\n\r\nThe Java programming language supports overloading methods, and Java can distinguish between methods with different method signatures. This means that methods within a class can have the same name if they have different parameter lists (there are some qualifications to this that will be discussed in the lesson titled \"Interfaces and Inheritance\").\r\nSuppose that you have a class that can use calligraphy to draw various types of data (strings, integers, and so on) and that contains a method for drawing each data type. It is cumbersome to use a new name for each method\u2014for example, drawString, drawInteger, drawFloat, and so on. In the Java programming language, you can use the same name for all the drawing methods but pass a different argument list to each method. Thus, the data drawing class might declare four methods named draw, each of which has a different parameter list.\r\n\r\npublic class DataArtist {\r\n    ...\r\n    public void draw(String s) {\r\n        ...\r\n    }\r\n    public void draw(int i) {\r\n        ...\r\n    }\r\n    public void draw(double f) {\r\n        ...\r\n    }\r\n    public void draw(int i, double f) {\r\n        ...\r\n    }\r\n}\r\n\r\nOverloaded methods are differentiated by the number and the type of the arguments passed into the method. In the code sample, draw(String s) and draw(int i) are distinct and unique methods because they require different argument types.\r\nYou cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.\r\nThe compiler does not consider return type when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type.\r\n\r\nNote: Overloaded methods should be used sparingly, as they can make code much less readable. \r\n\r\nProviding Constructors for Your Classes\r\n\r\nA class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarations\u2014except that they use the name of the class and have no return type. For example, Bicycle has one constructor:\r\npublic Bicycle(int startCadence, int startSpeed, int startGear) {\r\n    gear = startGear;\r\n    cadence = startCadence;\r\n    speed = startSpeed;\r\n}\r\n\r\nTo create a new Bicycle object called myBike, a constructor is called by the new operator:\r\nBicycle myBike = new Bicycle(30, 0, 8);\r\nnew Bicycle(30, 0, 8) creates space in memory for the object and initializes its fields.\r\nAlthough Bicycle only has one constructor, it could have others, including a no-argument constructor:\r\npublic Bicycle() {\r\n    gear = 1;\r\n    cadence = 10;\r\n    speed = 0;\r\n}\r\n\r\nBicycle yourBike = new Bicycle(); invokes the no-argument constructor to create a new Bicycle object called yourBike.\r\n\r\nBoth constructors could have been declared in Bicycle because they have different argument lists. As with methods, the Java platform differentiates constructors on the basis of the number of arguments in the list and their types. You cannot write two constructors that have the same number and type of arguments for the same class, because the platform would not be able to tell them apart. Doing so causes a compile-time error.\r\nYou don't have to provide any constructors for your class, but you must be careful when doing this. The compiler automatically provides a no-argument, default constructor for any class without constructors. This default constructor will call the no-argument constructor of the superclass. In this situation, the compiler will complain if the superclass doesn't have a no-argument constructor so you must verify that it does. If your class has no explicit superclass, then it has an implicit superclass of Object, which does have a no-argument constructor.\r\nYou can use a superclass constructor yourself. The MountainBike class at the beginning of this lesson did just that. This will be discussed later, in the lesson on interfaces and inheritance.\r\nYou can use access modifiers in a constructor's declaration to control which other classes can call the constructor.\r\n\r\nNote: If another class cannot call a MyClass constructor, it cannot directly create MyClass objects. \r\n\r\nPassing Information to a Method or a Constructor\r\n\r\nThe declaration for a method or a constructor declares the number and the type of the arguments for that method or constructor. For example, the following is a method that computes the monthly payments for a home loan, based on the amount of the loan, the interest rate, the length of the loan (the number of periods), and the future value of the loan:\r\n\r\npublic double computePayment(\r\n                  double loanAmt,\r\n                  double rate,\r\n                  double futureValue,\r\n                  int numPeriods) {\r\n    double interest = rate / 100.0;\r\n    double partial1 = Math.pow((1 + interest), \r\n                    - numPeriods);\r\n    double denominator = (1 - partial1) / interest;\r\n    double answer = (-loanAmt / denominator)\r\n                    - ((futureValue * partial1) / denominator);\r\n    return answer;\r\n}\r\nThis method has four parameters: the loan amount, the interest rate, the future value and the number of periods. The first three are double-precision floating point numbers, and the fourth is an integer. The parameters are used in the method body and at runtime will take on the values of the arguments that are passed in.\r\n\r\nNote:\u00A0Parameters refers to the list of variables in a method declaration. Arguments are the actual values that are passed in when the method is invoked. When you invoke a method, the arguments used must match the declaration's parameters in type and order. \r\n\r\nParameter Types\r\n\r\nYou can use any data type for a parameter of a method or a constructor. This includes primitive data types, such as doubles, floats, and integers, as you saw in the computePayment method, and reference data types, such as objects and arrays.\r\nHere's an example of a method that accepts an array as an argument. In this example, the method creates a new Polygon object and initializes it from an array of Point objects (assume that Point is a class that represents an x, y coordinate):\r\n\r\npublic Polygon polygonFrom(Point[] corners) {\r\n    // method body goes here\r\n}\r\n\r\nParameter Names\r\n\r\nWhen you declare a parameter to a method or a constructor, you provide a name for that parameter. This name is used within the method body to refer to the passed-in argument.\r\nThe name of a parameter must be unique in its scope. It cannot be the same as the name of another parameter for the same method or constructor, and it cannot be the name of a local variable within the method or constructor.\r\nA parameter can have the same name as one of the class's fields. If this is the case, the parameter is said to shadow the field. Shadowing fields can make your code difficult to read and is conventionally used only within constructors and methods that set a particular field. For example, consider the following Circle class and its setOrigin method:\r\npublic class Circle {\r\n    private int x, y, radius;\r\n    public void setOrigin(int x, int y) {\r\n        ...\r\n    }\r\n}\r\n\r\nThe Circle class has three fields: x, y, and radius. The setOrigin method has two parameters, each of which has the same name as one of the fields. Each method parameter shadows the field that shares its name. So using the simple names x or y within the body of the method refers to the parameter, not to the field. To access the field, you must use a qualified name. This will be discussed later in this lesson in the section titled \"Using the this Keyword.\"\r\nPassing Primitive Data Type Arguments\r\nPrimitive arguments, such as an int or a double, are passed into methods by value. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost. Here is an example:\r\n\r\npublic class PassPrimitiveByValue {\r\n\r\n    public static void main(String[] args) {\r\n           \r\n        int x = 3;\r\n           \r\n        // invoke passMethod() with \r\n        // x as argument\r\n        passMethod(x);\r\n           \r\n        // print x to see if its \r\n        // value has changed\r\n        System.out.println(\"After invoking passMethod, x = \" + x);\r\n           \r\n    }\r\n        \r\n    // change parameter in passMethod()\r\n    public static void passMethod(int p) {\r\n        p = 10;\r\n    }\r\n}\r\n\r\nWhen you run this program, the output is:\r\nAfter invoking passMethod, x = 3\r\n\r\nPassing Reference Data Type Arguments\r\n\r\nReference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object's fields can be changed in the method, if they have the proper access level.\r\nFor example, consider a method in an arbitrary class that moves Circle objects:\r\npublic void moveCircle(Circle circle, int deltaX, int deltaY) {\r\n    // code to move origin of circle to x+deltaX, y+deltaY\r\n    circle.setX(circle.getX() + deltaX);\r\n    circle.setY(circle.getY() + deltaY);\r\n        \r\n    // code to assign a new reference to circle\r\n    circle = new Circle(0, 0);\r\n}\r\n\r\nLet the method be invoked with these arguments:\r\nmoveCircle(myCircle, 23, 56)\r\nInside the method, circle initially refers to myCircle. The method changes the x and y coordinates of the object that circle references (i.e., myCircle) by 23 and 56, respectively. These changes will persist when the method returns. Then circle is assigned a reference to a new Circle object with x = y = 0. This reassignment has no permanence, however, because the reference was passed in by value and cannot change. Within the method, the object pointed to by circle has changed, but, when the method returns, myCircle still references the same Circle object as before the method was called.\r\n");
		textArea.setBounds(20, 40, 1170, 650);
		add(textArea);
		
		// set label for declaring class tutorial and size of label
		JLabel lblDeclaringClasses = new JLabel("Declaring Classes");
		lblDeclaringClasses.setFont(new Font("Times New Roman", Font.PLAIN, 30));
		lblDeclaringClasses.setBounds(494, 11, 227, 28);
		add(lblDeclaringClasses);

	}

}